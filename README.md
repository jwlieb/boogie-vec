# Boogie-Vec — Tiny Vector Search Service

**Boogie-Vec** is a small C++ service that loads an embedding snapshot and answers KNN queries over HTTP. 
It’s designed to be **simple to run**, easy to swap backends (brute-force → Annoy → FAISS), 
and fast enough for 10–50k vectors out of the box.

---

## Features
- HTTP/JSON API: `/load`, `/query`, `/stats`, `/healthz`
- Backends: `bruteforce` (default), `annoy`, `faiss` (optional)
- Snapshot I/O: binary float32 vectors + optional IDs JSON
- Latency tracking (p50/p95/p99), QPS over 1m window, uptime monitoring
- Structured JSON logging for queries
- Clean backend abstraction via `IndexBackend` interface
- Single binary, no external services

---

## Quickstart (2 minutes)

### 1. Build
```bash
mkdir build && cd build
cmake .. && make -j
```
*(or `bazel build //:server` if you use Bazel)*

### 2. Run the server
```bash
./build/boogie_vec_server 8080
# or with Docker (when available)
docker run -p 8080:8080 ghcr.io/you/boogie-vec:latest
```

### 3. Generate test data
```bash
# Generate 50 test vectors (384-dimensional)
python3 examples/ingest.py 50 384
```

### 4. Load snapshot
```bash
curl -X POST http://127.0.0.1:8080/load \
  -H 'content-type: application/json' \
  -d '{ "path": "/Users/jacksonlieb/boogie-vec/data/vectors.bin", "dim": 384, "metric": "cosine", "ids_path": "/Users/jacksonlieb/boogie-vec/data/ids.json", "backend":"bruteforce" }'
```

### 5. Query
```bash
curl -X POST http://127.0.0.1:8080/query \
  -H 'content-type: application/json' \
  -d '{ "k": 5, "vector": [0.1, -0.02, 0.05, ...] }'
```

### 6. Stats & Health
```bash
curl http://127.0.0.1:8080/stats
curl http://127.0.0.1:8080/healthz
```

### 7. Run Tests
```bash
# First generate test data, then run tests
python3 examples/ingest.py 10 384
./tests/test_boogie_vec.sh

# Or run smoke test (builds, starts server, runs full test suite)
./tests/smoke.sh
```

---

## Snapshot File Format

**vectors.bin (little-endian):**
```
uint32 dim
uint32 count
float32 data[count * dim]
```

**ids.json (optional):**
```json
["track_001", "track_002", "..."]
```

Generated by your ingestion script from `tracks.csv` + embeddings.

---

## API Reference

### `POST /load`
Load an index snapshot.
```json
{
  "path": "/abs/path/to/vectors.bin",
  "dim": 384,
  "metric": "cosine",
  "ids_path": "/abs/path/to/ids.json",
  "backend": "bruteforce",
  "n_trees": 50
}
```
**Backends:** `bruteforce` (default), `annoy` (requires pre-built index, integration pending)
**Error responses:** `{"error": {"code": "CODE", "message": "..."}}`

### `POST /query`
Return top-K nearest neighbors.
```json
{
  "k": 20,
  "vector": [0.12, -0.03, ...]
}
```
**Validation:** `k` must be > 0, vector dimension must match loaded index.

### `GET /stats`
Returns service stats including latency percentiles (p50/p95/p99), QPS over 1-minute window, and uptime.

### `GET /healthz`
Returns `ok` if ready.

---

## Architecture Overview

```
        +------------------------------+
        |  Boogie (TS app)             |
        |------------------------------|
        |  embeddings/ + vectorstore   |
        |  HTTP client (JSON)          |
        +---------------▲--------------+
                        |
                        |  HTTP / JSON
                        ▼
        +--------------------------------+
        |         Boogie-Vec (C++)       |
        |--------------------------------|
        |  HTTP Server / Route Handlers  |
        |  IndexBackend (pluggable)      |
        |  Snapshot I/O / Metrics / API  |
        +--------------------------------+
```

---

## Performance

Performance metrics are tracked via the `/stats` endpoint. Example benchmarks will be added as data is collected.

For reference, brute-force search scales roughly as O(N×d×k) where N is vector count, d is dimension, and k is requested neighbors.

---

## Architecture Notes

- **Backend Abstraction**: The `IndexBackend` interface allows swapping brute-force search with optimized backends (Annoy, FAISS) without changing server code.
- **Metrics**: Latency tracked via ring buffer (1000 samples), QPS calculated over 1-minute rolling window.
- **Threading**: Thread-safe state management with mutexes for concurrent query handling.

---

## Third-Party Libraries

This project includes the following third-party libraries:

- **cpp-httplib** (MIT License) - Single-header HTTP server library
- **nlohmann/json** (MIT License) - JSON for Modern C++

Both libraries are included as single-header files in `third_party/` for convenience. See [ATTRIBUTIONS.md](ATTRIBUTIONS.md) for details.

## Roadmap
- Binary float payloads for lower JSON overhead
- gRPC/Protobuf API with identical semantics
- Memory-mapped snapshots; live updates
- Prometheus `/metrics` endpoint; auth/quotas
